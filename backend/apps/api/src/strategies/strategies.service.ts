import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ForbiddenException,
} from '@nestjs/common';
import { PrismaService } from '@app/database';
import { ChainService } from '@app/blockchain';
import { CreateStrategyDto, UpdateStrategyDto } from './dto/strategy.dto';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class StrategiesService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly chain: ChainService,
    private readonly config: ConfigService,
  ) {}

  /**
   * Create a new strategy
   */
  async create(userAddress: string, dto: CreateStrategyDto) {
    // Validate weights sum to 10000 (100%)
    const totalWeight = dto.weights.reduce((sum, w) => sum + w, 0);
    if (totalWeight !== 10000) {
      throw new BadRequestException('Weights must sum to 10000 (100%)');
    }

    // Validate tokens and weights arrays have same length
    if (dto.tokens.length !== dto.weights.length) {
      throw new BadRequestException('Tokens and weights arrays must have same length');
    }

    // Get blockchain client
    // Map chainId to chain name: 10143 = Monad Testnet, 10200 = Monad Mainnet
    const MONAD_CHAIN_IDS = [10200, 10143];
    const chainName = MONAD_CHAIN_IDS.includes(dto.chainId) ? 'monad' : 'base';
    const client = this.chain.getPublicClient(chainName);

    // Get StrategyRegistry contract address
    const registryAddress = this.config.get(
      `blockchain.${chainName}.contracts.strategyRegistry`,
    );

    // Use provided strategyId (from frontend on-chain deployment) OR generate one
    // Frontend should deploy on-chain FIRST, then pass the strategyId here
    const strategyId = dto.strategyId ? BigInt(dto.strategyId) : BigInt(Date.now());

    // Ensure user exists in database (auto-register on first strategy creation)
    await this.prisma.user.upsert({
      where: { address: userAddress.toLowerCase() },
      update: {}, // No updates if user exists
      create: {
        address: userAddress.toLowerCase(),
        // nonce auto-generated by Prisma default(uuid())
      },
    });

    // Save to database
    const strategy = await this.prisma.strategy.create({
      data: {
        chainId: dto.chainId,
        strategyId,
        userAddress: userAddress.toLowerCase(),
        name: dto.name || `Strategy ${Date.now()}`,
        tokens: dto.tokens.map((t) => t.toLowerCase()),
        weights: dto.weights,
        rebalanceInterval: BigInt(dto.rebalanceInterval),
        delegatorAddress: dto.delegatorAddress?.toLowerCase() || null,
        strategyLogic: dto.strategyLogic || null,
        version: '1.0',
        isActive: true,
        // Mark as deployed if strategyId was provided (meaning frontend deployed on-chain first)
        isDeployed: !!dto.strategyId,
        // Save deployment transaction hash if provided
        deployTxHash: dto.deployTxHash || null,
      },
    });

    return this.formatStrategy(strategy);
  }

  /**
   * Get all strategies for a user
   */
  async findAll(userAddress: string, chainId?: number) {
    const where: any = {
      userAddress: userAddress.toLowerCase(),
    };

    if (chainId) {
      where.chainId = chainId;
    }

    const strategies = await this.prisma.strategy.findMany({
      where,
      include: {
        rebalances: {
          orderBy: { createdAt: 'desc' },
          take: 1,
        },
      },
      orderBy: { createdAt: 'desc' },
    });

    return strategies.map((s) => this.formatStrategy(s));
  }

  /**
   * Get a single strategy by ID
   */
  async findOne(id: string, userAddress: string) {
    const strategy = await this.prisma.strategy.findUnique({
      where: { id },
      include: {
        rebalances: {
          orderBy: { createdAt: 'desc' },
          take: 5,
        },
      },
    });

    if (!strategy) {
      throw new NotFoundException('Strategy not found');
    }

    // Verify ownership
    if (strategy.userAddress !== userAddress.toLowerCase()) {
      throw new ForbiddenException('You do not own this strategy');
    }

    return this.formatStrategy(strategy);
  }

  /**
   * Update a strategy
   */
  async update(id: string, userAddress: string, dto: UpdateStrategyDto) {
    // Verify ownership
    const strategy = await this.findOne(id, userAddress);

    // Validate weights if provided
    if (dto.weights) {
      const totalWeight = dto.weights.reduce((sum, w) => sum + w, 0);
      if (totalWeight !== 10000) {
        throw new BadRequestException('Weights must sum to 10000 (100%)');
      }

      if (dto.weights.length !== strategy.tokens.length) {
        throw new BadRequestException('Weights array length must match tokens array');
      }
    }

    // Update in database
    const updated = await this.prisma.strategy.update({
      where: { id },
      data: {
        ...(dto.delegatorAddress && { delegatorAddress: dto.delegatorAddress.toLowerCase() }),
        ...(dto.weights && { weights: dto.weights }),
        ...(dto.rebalanceInterval && { rebalanceInterval: BigInt(dto.rebalanceInterval) }),
        ...(dto.isActive !== undefined && { isActive: dto.isActive }),
      },
    });

    return this.formatStrategy(updated);
  }

  /**
   * Delete a strategy
   */
  async remove(id: string, userAddress: string) {
    // Verify ownership
    await this.findOne(id, userAddress);

    // Soft delete by marking inactive
    await this.prisma.strategy.update({
      where: { id },
      data: { isActive: false },
    });

    return { success: true, message: 'Strategy deactivated successfully' };
  }

  /**
   * Format strategy for API response
   */
  private formatStrategy(strategy: any) {
    const lastRebalance = strategy.rebalances?.[0]?.createdAt;
    const nextRebalance = lastRebalance
      ? new Date(lastRebalance.getTime() + Number(strategy.rebalanceInterval) * 1000)
      : null;

    return {
      ...strategy,
      strategyId: strategy.strategyId.toString(),
      rebalanceInterval: strategy.rebalanceInterval.toString(),
      lastRebalance,
      nextRebalance,
      rebalances: undefined, // Remove from response
    };
  }
}
